{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../../src/platform/node/util.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAEH,oCAA6C;AAE7C,0EAI2C;AAE3C,6CAA6C;AAQ7C,SAAgB,qBAAqB,CACnC,UAA6B;IAE7B,IAAI,UAAU,KAAK,yBAAiB,CAAC,KAAK,EAAE;QAC1C,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;aAC/C,yBAAyE,CAAC;KAC9E;SAAM;QACL,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE;aACjD,2BAA2E,CAAC;KAChF;AACH,CAAC;AAVD,sDAUC;AAED,SAAgB,IAAI,CAClB,SAAgE,EAChE,OAAqB,EACrB,WAAiC,EACjC,SAAqB,EACrB,OAA2C;IAE3C,MAAM,cAAc,GAAG,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAElD,MAAM,iBAAiB,GAAG,qBAAqB,CAC7C,SAAS,CAAC,oBAAoB,EAAE,CACjC,CAAC;IACF,MAAM,OAAO,GAAG,iBAAiB,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;IACzD,IAAI,OAAO,EAAE;QACX,MAAM,IAAI,GAAG,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,CAAC;QACxD,IAAI,IAAI,EAAE;YACR,IAAA,iCAAY,EACV,SAAS,EACT,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EACjB,wBAAwB,EACxB,SAAS,EACT,OAAO,CACR,CAAC;SACH;KACF;SAAM;QACL,OAAO,CAAC,IAAI,sCAAiB,CAAC,UAAU,CAAC,CAAC,CAAC;KAC5C;AACH,CAAC;AA3BD,oBA2BC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ServiceClientType } from '../types';\nimport { OTLPProtoExporterNodeBase } from './OTLPProtoExporterNodeBase';\nimport {\n  CompressionAlgorithm,\n  OTLPExporterError,\n  sendWithHttp,\n} from '@opentelemetry/otlp-exporter-base';\nimport type * as protobuf from 'protobufjs';\nimport * as root from '../../generated/root';\n\nexport interface ExportRequestType<T, R = T & { toJSON: () => unknown }> {\n  create(properties?: T): R;\n  encode(message: T, writer?: protobuf.Writer): protobuf.Writer;\n  decode(reader: protobuf.Reader | Uint8Array, length?: number): R;\n}\n\nexport function getExportRequestProto<ServiceRequest>(\n  clientType: ServiceClientType\n): ExportRequestType<ServiceRequest> {\n  if (clientType === ServiceClientType.SPANS) {\n    return root.opentelemetry.proto.collector.trace.v1\n      .ExportTraceServiceRequest as unknown as ExportRequestType<ServiceRequest>;\n  } else {\n    return root.opentelemetry.proto.collector.metrics.v1\n      .ExportMetricsServiceRequest as unknown as ExportRequestType<ServiceRequest>;\n  }\n}\n\nexport function send<ExportItem, ServiceRequest>(\n  collector: OTLPProtoExporterNodeBase<ExportItem, ServiceRequest>,\n  objects: ExportItem[],\n  compression: CompressionAlgorithm,\n  onSuccess: () => void,\n  onError: (error: OTLPExporterError) => void\n): void {\n  const serviceRequest = collector.convert(objects);\n\n  const exportRequestType = getExportRequestProto<ServiceRequest>(\n    collector.getServiceClientType()\n  );\n  const message = exportRequestType.create(serviceRequest);\n  if (message) {\n    const body = exportRequestType.encode(message).finish();\n    if (body) {\n      sendWithHttp(\n        collector,\n        Buffer.from(body),\n        'application/x-protobuf',\n        onSuccess,\n        onError\n      );\n    }\n  } else {\n    onError(new OTLPExporterError('No proto'));\n  }\n}\n"]}