import regexpAST from 'regexp-tree';
export const mergeDeclarations = (tomlDeclarations, userFunctionsConfig, internalFunctionsConfig, deployConfigDeclarations, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_featureFlags = {}) => {
    const functionsVisited = new Set();
    const declarations = [
        // INTEGRATIONS
        // 1. Declarations from the integrations deploy config
        ...getDeclarationsFromInput(deployConfigDeclarations, internalFunctionsConfig, functionsVisited),
        // 2. Declarations from the integrations ISC
        ...createDeclarationsFromFunctionConfigs(internalFunctionsConfig, functionsVisited),
        // USER
        // 3. Declarations from the users toml config
        ...getDeclarationsFromInput(tomlDeclarations, userFunctionsConfig, functionsVisited),
        // 4. Declarations from the users ISC
        ...createDeclarationsFromFunctionConfigs(userFunctionsConfig, functionsVisited),
    ];
    return declarations;
};
const getDeclarationsFromInput = (inputDeclarations, functionConfigs, functionsVisited) => {
    var _a;
    const declarations = [];
    // For any declaration for which we also have a function configuration object,
    // we replace the path because that object takes precedence.
    for (const declaration of inputDeclarations) {
        const config = functionConfigs[declaration.function];
        if (!config) {
            // If no config is found, add the declaration as is.
            declarations.push(declaration);
        }
        else if ((_a = config.path) === null || _a === void 0 ? void 0 : _a.length) {
            // If we have a path specified as either a string or non-empty array,
            // create a declaration for each path.
            const paths = Array.isArray(config.path) ? config.path : [config.path];
            paths.forEach((path) => {
                declarations.push({ ...declaration, cache: config.cache, path });
            });
        }
        else {
            // With an in-source config without a path, add the config to the declaration.
            const { path, excludedPath, ...rest } = config;
            declarations.push({ ...declaration, ...rest });
        }
        functionsVisited.add(declaration.function);
    }
    return declarations;
};
const createDeclarationsFromFunctionConfigs = (functionConfigs, functionsVisited) => {
    const declarations = [];
    for (const name in functionConfigs) {
        const { cache, path, method } = functionConfigs[name];
        // If we have a path specified, create a declaration for each path.
        if (!functionsVisited.has(name) && path) {
            const paths = Array.isArray(path) ? path : [path];
            paths.forEach((singlePath) => {
                const declaration = { function: name, path: singlePath };
                if (cache) {
                    declaration.cache = cache;
                }
                if (method) {
                    declaration.method = method;
                }
                declarations.push(declaration);
            });
        }
    }
    return declarations;
};
// Validates and normalizes a pattern so that it's a valid regular expression
// in Go, which is the engine used by our edge nodes.
export const parsePattern = (pattern) => {
    let enclosedPattern = pattern;
    if (!pattern.startsWith('^'))
        enclosedPattern = `^${enclosedPattern}`;
    if (!pattern.endsWith('$'))
        enclosedPattern = `${enclosedPattern}$`;
    const regexp = new RegExp(enclosedPattern);
    const newRegexp = regexpAST.transform(regexp, {
        Assertion(path) {
            // Lookaheads are not supported. If we find one, throw an error.
            if (path.node.kind === 'Lookahead') {
                throw new Error('Regular expressions with lookaheads are not supported');
            }
        },
        Group(path) {
            // Named captured groups in JavaScript use a different syntax than in Go.
            // If we find one, convert it to an unnamed capture group, which is valid
            // in both engines.
            if ('name' in path.node && path.node.name !== undefined) {
                path.replace({
                    ...path.node,
                    name: undefined,
                    nameRaw: undefined,
                });
            }
        },
    });
    // Strip leading and forward slashes.
    return newRegexp.toString().slice(1, -1);
};
